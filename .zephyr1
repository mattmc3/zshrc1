#!/bin/zsh
# .zephyr1
# > First things first - start your .zshrc off right with Zephyr lite
# Project Home: https://github.com/mattmc3/zephyr

#region bootstrap
#

# Set critical Zsh options.
setopt extended_glob interactive_comments

# Set Zsh locations.
typeset -gx __zsh_{config,cache,user_data}_dir
: ${__zsh_config_dir:=${ZDOTDIR:-${XDG_CONFIG_HOME:-$HOME/.config}/zsh}}
: ${__zsh_user_data_dir:=${XDG_DATA_HOME:-$HOME/.local/share}/zsh}
: ${__zsh_cache_dir:=${XDG_CACHE_HOME:-$HOME/.cache}/zsh}
mkdir -p $__zsh_config_dir $__zsh_user_data_dir $__zsh_cache_dir

# There's not really a post_zshrc event, so we're going to fake one by adding a
# function called run_post_zshrc to the precmd event. That function only runs once,
# and then unregisters itself. If the user wants to (or needs to because it doesn't
# play well with a plugin), they can run it themselves manually at the very end of
# their .zshrc, and then it unregisters the precmd event.

# Define a variable to hold actions run during the post_zshrc event.
typeset -ga post_zshrc_hook

# Add our new event.
function run_post_zshrc {
  # Run anything attached to the post_zshrc hook
  local fn
  for fn in $post_zshrc_hook; do
    # Uncomment to debug:
    # echo "post_zshrc is about to run: ${=fn}"
    "${=fn}"
  done

  # Now delete the precmd hook and self-remove this function and its list var so
  # that it only runs once, and doesn't keep running on every future precmd event.
  add-zsh-hook -d precmd run_post_zshrc
  unfunction -- run_post_zshrc
  unset -- post_zshrc_hook
}

# Attach run_post_zshrc to built-in precmd.
autoload -U add-zsh-hook
add-zsh-hook precmd run_post_zshrc

#
#endregion
#region helper
#

# Make a directory from a variable name.
function mkdirvar {
  emulate -L zsh
  local zdirvar
  for zdirvar in $@; do
    [[ -d "${(P)zdirvar}" ]] || mkdir -p "$(P){zdirvar}"
  done
}

# Cache the results of an eval command
function cached-eval {
  emulate -L zsh; setopt local_options extended_glob
  (( $# >= 2 )) || return 1

  : ${__zsh_cache_dir:=${XDG_CACHE_HOME:-$HOME/.cache}/zsh}
  local cmdname=$1; shift
  local cachefile=$__zsh_cache_dir/cached-eval/${cmdname}.zsh
  local -a cached=($cachefile(Nmh-20))
  # If the file has no size (is empty), or is older than 20 hours re-gen the cache.
  if [[ ! -s $cachefile ]] || (( ! ${#cached} )); then
    mkdir -p ${cachefile:h}
    "$@" >| $cachefile
  fi
  source $cachefile
}

# Check if a file can be autoloaded by trying to load it in a subshell.
function is-autoloadable {
  ( unfunction "$1"; autoload -U +X "$1" ) &> /dev/null
}

# Check if a name is a command, function, or alias.
function is-callable {
  (( $+commands[$1] || $+functions[$1] || $+aliases[$1] || $+builtins[$1] ))
}

# Check whether a string represents "true" (1, y, yes, t, true, o, on).
function is-true {
  [[ -n "$1" && "$1:l" == (1|y(es|)|t(rue|)|o(n|)) ]]
}

# OS checks.
function is-macos  { [[ "$OSTYPE" == darwin* ]] }
function is-linux  { [[ "$OSTYPE" == linux*  ]] }
function is-bsd    { [[ "$OSTYPE" == *bsd*   ]] }
function is-cygwin { [[ "$OSTYPE" == cygwin* ]] }
function is-termux { [[ "$OSTYPE" == linux-android ]] }

# Check term family.
function is-term-family {
  [[ $TERM = $1 || $TERM = $1-* ]]
}

# Check if tmux.
function is-tmux {
  is-term-family tmux || [[ -n "$TMUX" ]]
}

#
#endregion
#region environment
#
# Set Zsh options related to globbing.
setopt extended_glob         # Use more awesome globbing features.
setopt glob_dots             # Include dotfiles when globbing.
setopt NO_rm_star_silent     # Ask for confirmation for `rm *' or `rm path/*'

# Set general Zsh options.
setopt combining_chars       # Combine 0-len chars with the base character (eg: accents).
setopt interactive_comments  # Enable comments in interactive shell.
setopt rc_quotes             # Allow 'Hitchhikers''s Guide' instead of 'Hitchhikers'\''s Guide'.
setopt NO_mail_warning       # Don't print a warning message if a mail file has been accessed.
setopt NO_beep               # Don't beep on error in line editor.

# Set Zsh options related to job control.
setopt auto_resume           # Attempt to resume existing job before creating a new process.
setopt long_list_jobs        # List jobs in the long format by default.
setopt notify                # Report status of background jobs immediately.
setopt NO_bg_nice            # Don't run all background jobs at a lower priority.
setopt NO_check_jobs         # Don't report on jobs when shell exit.
setopt NO_hup                # Don't kill jobs on shell exit.

# Set XDG base dirs.
# https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
if zstyle -T ':zephyr:plugin:environment' use-xdg-basedirs; then
  export XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
  export XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
  export XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}
  export XDG_STATE_HOME=${XDG_STATE_HOME:-$HOME/.local/state}
  mkdir -p $XDG_CONFIG_HOME $XDG_CACHE_HOME $XDG_DATA_HOME $XDG_STATE_HOME
fi

# Editors
export EDITOR=${EDITOR:-nano}
export VISUAL=${VISUAL:-nano}
export PAGER=${PAGER:-less}

# Set browser.
if [[ "$OSTYPE" == darwin* ]]; then
  export BROWSER=${BROWSER:-open}
fi

# Set language.
export LANG=${LANG:-en_US.UTF-8}

# Set the default Less options.
# Mouse-wheel scrolling can be disabled with -X (disable screen clearing).
# Add -X to disable it.
if [[ -z "$LESS" ]]; then
  export LESS='-g -i -M -R -S -w -z-4'
fi

# Set the Less input preprocessor.
# Try both `lesspipe` and `lesspipe.sh` as either might exist on a system.
if [[ -z "$LESSOPEN" ]] && (( $#commands[(i)lesspipe(|.sh)] )); then
  export LESSOPEN="| /usr/bin/env $commands[(i)lesspipe(|.sh)] %s 2>&-"
fi

# Reduce key delay
export KEYTIMEOUT=${KEYTIMEOUT:-1}

# Make Apple Terminal behave.
if [[ "$OSTYPE" == darwin* ]]; then
  export SHELL_SESSIONS_DISABLE=${SHELL_SESSIONS_DISABLE:-1}
fi

# Use `< file` to quickly view the contents of any file.
[[ -z "$READNULLCMD" ]] || READNULLCMD=$PAGER

# Ensure path arrays do not contain duplicates.
typeset -gU cdpath fpath mailpath path

# Add /usr/local/bin to path.
path=(/usr/local/{,s}bin(N) $path)

# Set the list of directories that Zsh searches for programs.
typeset -gaU prepath
if [[ "${#prepath}" -eq 0 ]]; then
  zstyle -a ':zephyr:plugin:environment' 'prepath' 'prepath' \
  || prepath=(
      $HOME/{,s}bin(N)
      $HOME/.local/{,s}bin(N)
    )
fi

# If path gets prepended and is now out of order, do `path=($prepath $path)`.
path=($prepath $path)
#
#endregion
#region homebrew
#

() {
  # Where is brew?
  # Setup homebrew if it exists on the system.
  typeset -aU _brewcmd=(
    $commands[brew]
    $HOME/.homebrew/bin/brew(N)
    $HOME/.linuxbrew/bin/brew(N)
    /opt/homebrew/bin/brew(N)
    /usr/local/bin/brew(N)
    #/home/linuxbrew/.linuxbrew/bin/brew(N)
  )
  (( ${#_brewcmd} )) || return 1

  # brew shellenv
  if zstyle -t ':zephyr:plugin:homebrew' 'use-cache'; then
    cached-eval 'brew_shellenv' $_brewcmd[1] shellenv
  else
    source <($_brewcmd[1] shellenv)
  fi
  unset _brewcmd

  # Ensure user bins preceed homebrew in path.
  path=($prepath $path)

  # Default to no tracking.
  HOMEBREW_NO_ANALYTICS=${HOMEBREW_NO_ANALYTICS:-1}

  # Add brewed Zsh to fpath
  if [[ -d "$HOMEBREW_PREFIX/share/zsh/site-functions" ]]; then
    fpath+=("$HOMEBREW_PREFIX/share/zsh/site-functions")
  fi

  # Add keg-only completions to fpath
  zstyle -a ':zephyr:plugin:homebrew' 'keg-only-brews' '_kegonly' \
    || _kegonly=(curl ruby sqlite)
  for _keg in $_kegonly; do
    fpath=($HOMEBREW_PREFIX/opt/${_keg}/share/zsh/site-functions(/N) $fpath)
  done
  unset _keg{,only}

  # Set aliases.
  if ! zstyle -t ':zephyr:plugin:homebrew:alias' skip; then
    alias brewup="brew update && brew upgrade && brew cleanup"
    alias brewinfo="brew leaves | xargs brew desc --eval-all"
    alias brewdeps='brew leaves | xargs brew deps --installed --for-each | awk ''{leaf=$1;$1=""; printf "%s\033[34m%s\033[0m\n",leaf,$0}'''

    # Handle brew on multi-user systems.
    _brew_owner="$(stat -f "%Su" "$HOMEBREW_PREFIX" 2>/dev/null)"
    if [[ -n "$_brew_owner" ]] && [[ "$(whoami)" != "$_brew_owner" ]]; then
      alias brew="sudo -Hu '$_brew_owner' brew"
    fi
    unset _brew_owner
  fi
}

#
#endregion
#region history
#

() {
  # Set Zsh options related to history.
  setopt bang_hist               # Treat the '!' character specially during expansion.
  setopt extended_history        # Write the history file in the ':start:elapsed;command' format.
  setopt hist_expire_dups_first  # Expire a duplicate event first when trimming history.
  setopt hist_find_no_dups       # Do not display a previously found event.
  setopt hist_ignore_all_dups    # Delete an old recorded event if a new event is a duplicate.
  setopt hist_ignore_dups        # Do not record an event that was just recorded again.
  setopt hist_ignore_space       # Do not record an event starting with a space.
  setopt hist_reduce_blanks      # Remove extra blanks from commands added to the history list.
  setopt hist_save_no_dups       # Do not write a duplicate event to the history file.
  setopt hist_verify             # Do not execute immediately upon history expansion.
  setopt inc_append_history      # Write to the history file immediately, not when the shell exits.
  setopt NO_hist_beep            # Don't beep when accessing non-existent history.
  setopt NO_share_history        # Don't share history between all sessions.

  # Set the path to the default history file.
  if zstyle -s ':zephyr:plugin:history' histfile 'HISTFILE'; then
    # Make sure the user didn't store a HISTFILE with a leading '~'.
    HISTFILE="${~HISTFILE}"
  else
    if zstyle -T ':zephyr:plugin:history' use-xdg-basedirs; then
      HISTFILE="${__zsh_user_data_dir}/zsh_history"
    else
      HISTFILE="${ZDOTDIR:-$HOME}/.zsh_history"
    fi
  fi

  # Make sure the HISTFILE's directory exists.
  [[ -d "${HISTFILE:h}" ]] || mkdir -p "${HISTFILE:h}"

  # Set history file size.
  zstyle -s ':zephyr:plugin:history' savehist 'SAVEHIST' \
    || SAVEHIST=100000

  # Set session history size.
  zstyle -s ':zephyr:plugin:history' histsize 'HISTSIZE' \
    || HISTSIZE=20000

  # Set history aliases.
  if ! zstyle -t ':zephyr:plugin:history:alias' skip; then
    alias hist='fc -li'
    alias history-stat="history 0 | awk '{print \$2}' | sort | uniq -c | sort -n -r | head"
  fi
}

#
#endregion
#region directory
#

() {
  # Set Zsh options related to directories, globbing, and I/O.
  setopt auto_pushd         # Make cd push the old directory onto the dirstack.
  setopt pushd_minus        # Exchanges meanings of +/- when navigating the dirstack.
  setopt pushd_silent       # Do not print the directory stack after pushd or popd.
  setopt pushd_to_home      # Push to home directory when no argument is given.
  setopt multios            # Write to multiple descriptors.
  setopt extended_glob      # Use extended globbing syntax (#,~,^).
  setopt glob_dots          # Don't hide dotfiles from glob patterns.
  setopt NO_clobber         # Don't overwrite files with >. Use >| to bypass.
  setopt NO_rm_star_silent  # Ask for confirmation for `rm *' or `rm path/*'

  # Set directory aliases.
  if ! zstyle -t ':zephyr:plugin:directory:alias' skip; then
    alias -- -='cd -'
    alias dirh='dirs -v'

    _dotdot=".."
    for _index in {1..9}; do
      alias "$_index"="cd -${_index}"      # dirstack aliases (eg: "2"="cd -2")
      alias -g "..${_index}"="${_dotdot}"  # backref aliases (eg: "..3"="../../..")
      _dotdot+="/.."
    done
    unset _dotdot _index
  fi

  # Quickly go up any number of directories.
  function up {
    local parents="${1:-1}"
    if [[ ! "$parents" -gt 0 ]]; then
      echo >&2 "usage: up [<num>]"
      return 1
    fi
    local dotdots=".."
    while (( --parents )); do
      dotdots+="/.."
    done
    cd "$dotdots"
  }
}

#
#endregion
#region color
#

() {
  # Return if requirements are not found.
  [[ "$TERM" != 'dumb' ]] || return 1

  # Built-in zsh colors.
  autoload -Uz colors && colors

  # Colorize man pages.
  export LESS_TERMCAP_md=${LESS_TERMCAP_md:-$fg_bold[blue]}   # start bold
  export LESS_TERMCAP_mb=${LESS_TERMCAP_mb:-$fg_bold[blue]}   # start blink
  export LESS_TERMCAP_so=${LESS_TERMCAP_so:-$'\e[00;47;30m'}  # start standout: white bg, black fg
  export LESS_TERMCAP_us=${LESS_TERMCAP_us:-$'\e[04;35m'}     # start underline: underline magenta
  export LESS_TERMCAP_se=${LESS_TERMCAP_se:-$reset_color}     # end standout
  export LESS_TERMCAP_ue=${LESS_TERMCAP_ue:-$reset_color}     # end underline
  export LESS_TERMCAP_me=${LESS_TERMCAP_me:-$reset_color}     # end bold/blink

  # Set LS_COLORS using (g)dircolors if found.
  if [[ -z "$LS_COLORS" ]]; then
    _dircolors_cmds=(
      $commands[dircolors](N) $commands[gdircolors](N)
    )
    if (( $#_dircolors_cmds )); then
      if zstyle -t ':zephyr:plugin:color' 'use-cache'; then
        cached-eval "${_dircolors_cmds[1]:t}" "$_dircolors_cmds[1]" --sh
      else
        source <("$_dircolors_cmds[1]" --sh)
      fi
    fi
    unset _dircolors_cmds

    # Pick a reasonable default for LS_COLORS if it hasn't been set by this point.
    export LS_COLORS="${LS_COLORS:-di=34:ln=35:so=32:pi=33:ex=31:bd=1;36:cd=1;33:su=30;41:sg=30;46:tw=30;42:ow=30;43}"
  fi

  # Missing dircolors is a good indicator of a BSD system. Set LSCOLORS for macOS/BSD.
  if (( ! $+commands[dircolors] )); then
    # For BSD systems, set LSCOLORS.
    export CLICOLOR=${CLICOLOR:-1}
    export LSCOLORS="${LSCOLORS:-exfxcxdxbxGxDxabagacad}"
  fi

  # Set aliases.
  if ! zstyle -t ':zephyr:plugin:color:alias' skip; then
    # Print a simple colormap.
    alias colormap='for i in {0..255}; do print -Pn "%K{$i}  %k%F{$i}${(l:3::0:)i}%f " ${${(M)$((i%6)):#3}:+"\n"}; done'

    # Set colors for grep.
    alias grep="${aliases[grep]:-grep} --color=auto"

    # Set colors for ls.
    alias ls="${aliases[ls]:-ls} --color=auto"
    if (( $+commands[gls] )); then
      alias gls="${aliases[gls]:-gls} --color=auto"
    fi

    # Set colors for diff.
    if command diff --color /dev/null{,} &>/dev/null; then
      alias diff="${aliases[diff]:-diff} --color"
    fi
  fi

  # Colorize completions.
  zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
}

#
#endregion
#region editor
#

() {
  # Return if requirements are not found.
  [[ "$TERM" != 'dumb' ]] || return 1

  #
  # Options
  #

  # Set Zsh editor options.
  setopt NO_beep                 # Do not beep on error in line editor.
  setopt NO_flow_control         # Allow the usage of ^Q/^S in the context of zsh.

  #
  # Variables
  #

  # Treat these characters as part of a word.
  zstyle -s ':zephyr:plugin:editor' wordchars 'WORDCHARS' || \
  WORDCHARS='*?_-.[]~&;!#$%^(){}<>'

  # Use human-friendly identifiers.
  zmodload zsh/terminfo
  typeset -gA key_info

  # Modifiers
  key_info=(
    'Control' '\C-'
    'Escape'  '\e'
    'Meta'    '\M-'
  )

  # Basic keys
  key_info+=(
    'Backspace' "^?"
    'Delete'    "^[[3~"
    'F1'        "$terminfo[kf1]"
    'F2'        "$terminfo[kf2]"
    'F3'        "$terminfo[kf3]"
    'F4'        "$terminfo[kf4]"
    'F5'        "$terminfo[kf5]"
    'F6'        "$terminfo[kf6]"
    'F7'        "$terminfo[kf7]"
    'F8'        "$terminfo[kf8]"
    'F9'        "$terminfo[kf9]"
    'F10'       "$terminfo[kf10]"
    'F11'       "$terminfo[kf11]"
    'F12'       "$terminfo[kf12]"
    'Insert'    "$terminfo[kich1]"
    'Home'      "$terminfo[khome]"
    'PageUp'    "$terminfo[kpp]"
    'End'       "$terminfo[kend]"
    'PageDown'  "$terminfo[knp]"
    'Up'        "$terminfo[kcuu1]"
    'Left'      "$terminfo[kcub1]"
    'Down'      "$terminfo[kcud1]"
    'Right'     "$terminfo[kcuf1]"
    'BackTab'   "$terminfo[kcbt]"
  )

  # Mod plus another key
  key_info+=(
    'AltLeft'         "${key_info[Escape]}${key_info[Left]} \e[1;3D"
    'AltRight'        "${key_info[Escape]}${key_info[Right]} \e[1;3C"
    'ControlLeft'     '\e[1;5D \e[5D \e\e[D \eOd'
    'ControlRight'    '\e[1;5C \e[5C \e\e[C \eOc'
    'ControlPageUp'   '\e[5;5~'
    'ControlPageDown' '\e[6;5~'
  )

  #
  # Functions
  #

  # Runs bindkey but for all of the keymaps. Running it with no arguments will
  # print out the mappings for all of the keymaps.
  function bindkey-all {
    local keymap=''
    for keymap in $(bindkey -l); do
      [[ "$#" -eq 0 ]] && printf "#### %s\n" "${keymap}" 1>&2
      bindkey -M "${keymap}" "$@"
    done
  }

  function update-cursor-style {
    # We currently only support the xterm family of terminals
    if ! is-term-family xterm && ! is-term-family rxvt && ! is-tmux; then
      return
    fi

    if bindkey -lL main | grep viins > /dev/null; then
      # For vi-mode we
      case $KEYMAP in
        vicmd)      printf '\e[2 q';;
        viins|main) printf '\e[6 q';;
      esac
    else
      # If we're in emacs mode, we always want a line cursor
      printf '\e[6 q'
    fi
  }
  zle -N update-cursor-style

  # Enables terminal application mode
  function zle-line-init {
    # The terminal must be in application mode when ZLE is active for $terminfo
    # values to be valid.
    if (( $+terminfo[smkx] )); then
      # Enable terminal application mode.
      echoti smkx
    fi

    # Ensure we have the correct cursor. We could probably do this less
    # frequently, but this does what we need and shouldn't incur that much
    # overhead.
    zle update-cursor-style
  }
  zle -N zle-line-init

  # Disables terminal application mode
  function zle-line-finish {
    # The terminal must be in application mode when ZLE is active for $terminfo
    # values to be valid.
    if (( $+terminfo[rmkx] )); then
      # Disable terminal application mode.
      echoti rmkx
    fi
  }
  zle -N zle-line-finish

  # Resets the prompt when the keymap changes
  function zle-keymap-select {
    zle update-cursor-style

    zle reset-prompt
    zle -R
  }
  zle -N zle-keymap-select

  # Expands .... to ../..
  function expand-dot-to-parent-directory-path {
    if [[ $LBUFFER = *.. ]]; then
      LBUFFER+='/..'
    else
      LBUFFER+='.'
    fi
  }
  zle -N expand-dot-to-parent-directory-path

  # Inserts 'sudo ' at the beginning of the line.
  function prepend-sudo {
    if [[ "$BUFFER" != su(do|)\ * ]]; then
      BUFFER="sudo $BUFFER"
      (( CURSOR += 5 ))
    fi
  }
  zle -N prepend-sudo

  # Expand aliases
  function glob-alias {
    local -a noexpand_aliases
    zstyle -a ':zephyr:plugin:editor:glob-alias' 'noexpand' 'noexpand_aliases' \
      || noexpand_aliases=()

    # Get last word to the left of the cursor:
    # (A) makes it an array even if there's only one element
    # (z) splits into words using shell parsing
    local word=${${(Az)LBUFFER}[-1]}
    if [[ $noexpand_aliases[(Ie)$word] -eq 0 ]]; then
      zle _expand_alias
      # zle expand-word
    fi
    zle self-insert
  }
  zle -N glob-alias

  # Toggle the comment character at the start of the line. This is meant to work
  # around a buggy implementation of pound-insert in zsh.
  #
  # This is currently only used for the emacs keys because vi-pound-insert has
  # been reported to work properly.
  function pound-toggle {
    if [[ "$BUFFER" = '#'* ]]; then
      # Because of an oddity in how zsh handles the cursor when the buffer size
      # changes, we need to make this check before we modify the buffer and let
      # zsh handle moving the cursor back if it's past the end of the line.
      if [[ $CURSOR != $#BUFFER ]]; then
        (( CURSOR -= 1 ))
      fi
      BUFFER="${BUFFER:1}"
    else
      BUFFER="#$BUFFER"
      (( CURSOR += 1 ))
    fi
  }
  zle -N pound-toggle

  # https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/fancy-ctrl-z/fancy-ctrl-z.plugin.zsh
  # https://sheerun.net/2014/03/21/how-to-boost-your-vim-productivity/
  function symmetric-ctrl-z {
    if [[ $#BUFFER -eq 0 ]]; then
      BUFFER="fg"
      zle accept-line -w
    else
      zle push-input -w
      zle clear-screen -w
    fi
  }
  zle -N symmetric-ctrl-z

  # https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/magic-enter
  (( $+functions[magic-enter-cmd] )) ||
  function magic-enter-cmd {
    local cmd
    zstyle -s ':zephyr:plugin:editor:magic-enter' command 'cmd' ||
      cmd="ls ."

    if command git rev-parse --is-inside-work-tree &>/dev/null; then
      zstyle -s ':zephyr:plugin:editor:magic-enter' git-command 'cmd' ||
        cmd="git status -sb ."
    fi
    echo $cmd
  }

  function magic-enter {
    # Only run MAGIC_ENTER commands when in PS1 and command line is empty
    # http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#User_002dDefined-Widgets
    if [[ -n "$BUFFER" || "$CONTEXT" != start ]]; then
      return
    fi
    BUFFER=$(magic-enter-cmd)
  }

  # Wrapper for the accept-line zle widget (run when pressing Enter)
  # If the wrapper already exists don't redefine it
  if (( ! ${+functions[_magic-enter_accept-line]} )); then
    case "$widgets[accept-line]" in
      # Override the current accept-line widget, calling the old one
      user:*) zle -N _magic-enter_orig_accept-line "${widgets[accept-line]#user:}"
        function _magic-enter_accept-line {
          magic-enter
          zle _magic-enter_orig_accept-line -- "$@"
        } ;;
      # If no user widget defined, call the original accept-line widget
      builtin) function _magic-enter_accept-line {
          magic-enter
          zle .accept-line
        } ;;
    esac
    zle -N accept-line _magic-enter_accept-line
  fi

  #
  # Init
  #

  # Reset to default key bindings
  bindkey -d

  #
  # Keybinds
  #

  # Global keybinds
  typeset -gA global_keybinds
  global_keybinds=(
    "$key_info[Home]"   beginning-of-line
    "$key_info[End]"    end-of-line
    "$key_info[Delete]" delete-char
  )

  # emacs and vi insert mode keybinds
  typeset -gA viins_keybinds
  viins_keybinds=(
    "$key_info[Backspace]" backward-delete-char
    "$key_info[Control]W"  backward-kill-word
  )

  # vi command mode keybinds
  typeset -gA vicmd_keybinds
  vicmd_keybinds=(
    "$key_info[Delete]" delete-char
  )

  # Special case for ControlLeft and ControlRight because they have multiple
  # possible binds.
  for key in "${(s: :)key_info[ControlLeft]}" "${(s: :)key_info[AltLeft]}"; do
    bindkey -M emacs "$key" emacs-backward-word
    bindkey -M viins "$key" vi-backward-word
    bindkey -M vicmd "$key" vi-backward-word
  done
  for key in "${(s: :)key_info[ControlRight]}" "${(s: :)key_info[AltRight]}"; do
    bindkey -M emacs "$key" emacs-forward-word
    bindkey -M viins "$key" vi-forward-word
    bindkey -M vicmd "$key" vi-forward-word
  done

  # Bind all global and viins keys to the emacs keymap
  for key bind in ${(kv)global_keybinds} ${(kv)viins_keybinds}; do
    bindkey -M emacs "$key" "$bind"
  done

  # Bind all global, vi, and viins keys to the viins keymap
  for key bind in ${(kv)global_keybinds} ${(kv)viins_keybinds}; do
    bindkey -M viins "$key" "$bind"
  done

  # Bind all global, vi, and vicmd keys to the vicmd keymap
  for key bind in ${(kv)global_keybinds} ${(kv)vicmd_keybinds}; do
    bindkey -M vicmd "$key" "$bind"
  done

  # Keybinds for emacs and vi insert mode
  for keymap in 'emacs' 'viins'; do
    # Expand .... to ../..
    if zstyle -t ':zephyr:plugin:editor' dot-expansion; then
      bindkey -M "$keymap" "." expand-dot-to-parent-directory-path
    fi
  done

  # Do not expand .... to ../.. during incremental search.
  if zstyle -t ':zephyr:plugin:editor' dot-expansion; then
    bindkey -M isearch . self-insert 2> /dev/null
  fi

  # Toggle comment at the start of the line. Note that we use pound-toggle for emacs
  # mode, which is similar to pount insert, but meant to work around some bugs.
  bindkey -M emacs "$key_info[Escape];" pound-toggle
  bindkey -M vicmd "#" vi-pound-insert

  # Expand aliases
  if zstyle -t ':zephyr:plugin:editor' glob-alias; then
    # space expands all aliases, including global
    bindkey -M emacs " " glob-alias
    bindkey -M viins " " glob-alias

    # control-space to make a normal space
    bindkey -M emacs "^ " magic-space
    bindkey -M viins "^ " magic-space

    # normal space during searches
    bindkey -M isearch " " magic-space
  fi

  # ctrl-z sends things to the background - make it also bring to forground
  if zstyle -t ':zephyr:plugin:editor' 'symmetric-ctrl-z'; then
    bindkey -M emacs '^Z' symmetric-ctrl-z
    bindkey -M viins '^Z' symmetric-ctrl-z
  fi

  #
  # Layout
  #

  # Set the key layout.
  zstyle -s ':zephyr:plugin:editor' key-bindings 'key_bindings'
  if [[ "$key_bindings" == (emacs|) ]]; then
    bindkey -e
  elif [[ "$key_bindings" == vi ]]; then
    bindkey -v
  else
    print "editor: invalid key bindings: $key_bindings" >&2
  fi

  unset bind key{,_bindings} {vicmd,viins,global}_keybinds
}

#
#endregion
#region utility
#

() {
  # Use built-in paste magic.
  autoload -Uz bracketed-paste-url-magic
  zle -N bracketed-paste bracketed-paste-url-magic
  autoload -Uz url-quote-magic
  zle -N self-insert url-quote-magic

  # Load more specific 'run-help' function from $fpath.
  (( $+aliases[run-help] )) && unalias run-help && autoload -Uz run-help
  alias help=run-help

  # Make ls more useful.
  if (( ! $+commands[dircolors] )) && [[ "$OSTYPE" != darwin* ]]; then
    # Group dirs first on non-BSD systems
    alias ls="${aliases[ls]:-ls} --group-directories-first"
  fi
  # Show human readable file sizes.
  alias ls="${aliases[ls]:-ls} -h"

  # Ensure python commands exist.
  if (( $+commands[python3] )) && ! (( $+commands[python] )); then
    alias python=python3
  fi
  if (( $+commands[pip3] )) && ! (( $+commands[pip] )); then
    alias pip=pip3
  fi

  # Ensure envsubst command exists.
  if ! (( $+commands[envsubst] )); then
    alias envsubst="python -c 'import os,sys;[sys.stdout.write(os.path.expandvars(l)) for l in sys.stdin]'"
  fi

  # Ensure hd (hex dump) command exists.
  if ! (( $+commands[hd] )) && (( $+commands[hexdump] )); then
    alias hd="hexdump -C"
  fi

  # Ensure open command exists.
  if ! (( $+commands[open] )); then
    if [[ "$OSTYPE" == cygwin* ]]; then
      alias open='cygstart'
    elif [[ "$OSTYPE" == linux-android ]]; then
      alias open='termux-open'
    elif (( $+commands[xdg-open] )); then
      alias open='xdg-open'
    fi
  fi

  # Ensure pbcopy/pbpaste commands exist.
  if ! (( $+commands[pbcopy] )); then
    if [[ "$OSTYPE" == cygwin* ]]; then
      alias pbcopy='tee > /dev/clipboard'
      alias pbpaste='cat /dev/clipboard'
    elif [[ "$OSTYPE" == linux-android ]]; then
      alias pbcopy='termux-clipboard-set'
      alias pbpaste='termux-clipboard-get'
    elif (( $+commands[wl-copy] && $+commands[wl-paste] )); then
      alias pbcopy='wl-copy'
      alias pbpaste='wl-paste'
    elif [[ -n $DISPLAY ]]; then
      if (( $+commands[xclip] )); then
        alias pbcopy='xclip -selection clipboard -in'
        alias pbpaste='xclip -selection clipboard -out'
      elif (( $+commands[xsel] )); then
        alias pbcopy='xsel --clipboard --input'
        alias pbpaste='xsel --clipboard --output'
      fi
    fi
  fi

  # Cross platform `sed -i` syntax.
  function sedi {
    # GNU/BSD
    sed --version &>/dev/null && sed -i -- "$@" || sed -i "" "$@"
  }
}

#
#endregion
#region zfunctions
#

() {
  ##? autoload-dir - Autoload function files in directory
  function autoload-dir {
    local zdir
    local -a zautoloads
    for zdir in $@; do
      [[ -d "$zdir" ]] || continue
      fpath=("$zdir" $fpath)
      zautoloads=($zdir/*~_*(N.:t))
      (( $#zautoloads > 0 )) && autoload -Uz $zautoloads
    done
  }

  ##? funcsave - Save a function
  function funcsave {
    emulate -L zsh; setopt local_options
    : ${ZFUNCDIR:=$__zsh_config_dir/functions}

    # check args
    if (( $# == 0 )); then
      echo >&2 "funcsave: Expected at least 1 args, got only 0."
      return 1
    elif ! typeset -f "$1" > /dev/null; then
      echo >&2 "funcsave: Unknown function '$1'."
      return 1
    elif [[ ! -d "$ZFUNCDIR" ]]; then
      echo >&2 "funcsave: Directory not found '$ZFUNCDIR'."
      return 1
    fi

    # make sure the function is loaded in case it's already lazy
    autoload +X "$1" > /dev/null

    # remove first/last lines (ie: 'function foo {' and '}') and de-indent one level
    type -f "$1" | awk 'NR>2 {print prev} {gsub(/^\t/, "", $0); prev=$0}' >| "$ZFUNCDIR/$1"
  }

  ##? funced - edit the function specified
  function funced {
    emulate -L zsh; setopt local_options
    : ${ZFUNCDIR:=$__zsh_config_dir/functions}

    # check args
    if (( $# == 0 )); then
      echo >&2 "funced: Expected at least 1 args, got only 0."
      return 1
    elif [[ ! -d "$ZFUNCDIR" ]]; then
      echo >&2 "funced: Directory not found '$ZFUNCDIR'."
      return 1
    fi

    # new function definition: make a file template
    if [[ ! -f "$ZFUNCDIR/$1" ]]; then
      local -a funcstub
      funcstub=(
        "#\!/bin/zsh"
        "#function $1 {"
        ""
        "#}"
        "#$1 \"\$@\""
      )
      printf '%s\n' "${funcstub[@]}" > "$ZFUNCDIR/$1"
      autoload -Uz "$ZFUNCDIR/$1"
    fi

    # open the function file
    if [[ -n "$VISUAL" ]]; then
      $VISUAL "$ZFUNCDIR/$1"
    else
      ${EDITOR:-vim} "$ZFUNCDIR/$1"
    fi
  }

  ##? funcfresh - Reload an autoload function
  function funcfresh {
    if (( $# == 0 )); then
      echo >&2 "funcfresh: Expecting function argument."
      return 1
    elif ! (( $+functions[$1] )); then
      echo >&2 "funcfresh: Function not found '$1'."
      return 1
    fi
    unfunction $1
    autoload -Uz $1
  }

  # Set ZFUNCDIR.
  if [[ -z "$ZFUNCDIR" ]]; then
    zstyle -s ':zephyr:plugin:zfunctions' directory 'ZFUNCDIR' \
    || ZFUNCDIR="$__zsh_config_dir/functions"
    ZFUNCDIR="${~ZFUNCDIR}"
  fi

  # Autoload ZFUNCDIR.
  if [[ -d "$ZFUNCDIR" ]]; then
    autoload-dir $ZFUNCDIR(N/) $ZFUNCDIR/*(N/)
  fi
}

#
#endregion
#region prompt
#
# Prompt options
setopt prompt_subst       # Expand parameters in prompt variables.
#setopt transient_rprompt  # Remove right prompt artifacts from prior commands.

# Set 2 space indent for each new level in a multi-line script. This can then be
# overridden by a prompt or plugin, but is a better default than Zsh's.
PS2='${${${(%):-%_}//[^ ]}// /  }    '

# Wrap powerlevel10k prompt to support themes directory
function prompt_p10k_setup {
  if [[ -n "$1" ]]; then
    local -a configs=($__zsh_config_dir/themes/$1.p10k.zsh(N))
    (( $#configs )) && source $configs[1]
  fi
  prompt_powerlevel10k_setup
}

# Make starship work with built-in prompt system.
function prompt_starship_setup {
  # When loaded through the prompt command, these prompt_* options will be enabled
  prompt_opts=(cr percent sp subst)

  # Set the starship config based on the argument if provided.
  if [[ -n "$1" ]]; then
    local -a configs=(
      "$__zsh_config_dir/themes/${1}.toml"(N)
      "${XDG_CONFIG_HOME:-$HOME/.config}/starship/${1}.toml"(N)
      "$ZEPHYR_HOME/plugins/prompt/themes/${1}.toml"(N)
    )
    (( $#configs )) && export STARSHIP_CONFIG=$configs[1]
  fi

  # Initialize starship.
  if zstyle -t ':zephyr:plugin:prompt' 'use-cache'; then
    cached-eval 'starship-init-zsh' starship init zsh
  else
    source <(starship init zsh)
  fi
}

# Wrap promptinit.
function promptinit {
  # Initialize real built-in prompt system.
  unfunction promptinit
  autoload -Uz promptinit && promptinit

  # Hook P10k into Zsh's prompt system.
  (( $+functions[prompt_powerlevel10k_setup] )) \
    && prompt_themes+=( p10k ) \
    || unfunction prompt_p10k_setup

  # Hook starship into Zsh's prompt system.
  (( $+commands[starship] )) \
    && prompt_themes+=( starship ) \
    || unfunction prompt_starship_setup

  # Keep prompt array sorted.
  prompt_themes=( "${(@on)prompt_themes}" )

  # We can run promptinit early, and if we did we no longer need a post_zshrc hook.
  post_zshrc_hook=(${post_zshrc_hook:#run_promptinit})
}

function run_promptinit {
  # Initialize the built-in prompt system.
  autoload -Uz promptinit && promptinit

  # Set the prompt if specified.
  local -a prompt_argv
  zstyle -a ':zephyr:plugin:prompt' theme 'prompt_argv' \
    || prompt_argv=(starship zephyr)
  if [[ $TERM == (dumb|linux|*bsd*) ]]; then
    prompt 'off'
  elif (( $#prompt_argv > 0 )); then
    prompt "$prompt_argv[@]"
  fi
}

# Allow the user to bypass the confd deferral and run it immediately. Otherwise, we
# hook run_confd to the custom post_zshrc event.
if zstyle -t ':zephyr:plugin:prompt' immediate; then
  run_promptinit || return 1
else
  post_zshrc_hook+=(run_promptinit)
fi
#
#endregion
#region compstyle
#

() {
  function compstyle_zephyr_help {
    echo "A composite of the grml, prezto, and ohmyzsh completions."
    echo "You can invoke it with the following command:"
    echo
    echo "  compstyle zephyr"
    echo
    echo "More information available at: https://github.com/mattmc3/zephyr"
  }

  function compstyle_zephyr_setup {
    # Pre-reqs.
    : ${__zsh_cache_dir:=${XDG_CACHE_HOME:-$HOME/.cache}/zsh}
    [[ -d $__zsh_cache_dir ]] || mkdir -p $__zsh_cache_dir

    # Standard style used by default for 'list-colors'
    LS_COLORS=${LS_COLORS:-'di=34:ln=35:so=32:pi=33:ex=31:bd=36;01:cd=33;01:su=31;40;07:sg=36;40;07:tw=32;40;07:ow=33;40;07:'}

    # Defaults.
    zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
    zstyle ':completion:*:default' list-prompt '%S%M matches%s'

    # Use caching to make completion for commands such as dpkg and apt usable.
    zstyle ':completion::complete:*' use-cache on
    zstyle ':completion::complete:*' cache-path "$__zsh_cache_dir/zcompcache"

    # Case-insensitive (all), partial-word, and then substring completion.
    if zstyle -t ':zephyr:plugin:compstyle:*' case-sensitive; then
      zstyle ':completion:*' matcher-list 'r:|=*' 'l:|=* r:|=*'
      setopt case_glob
    else
      zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|=*' 'l:|=* r:|=*'
      unsetopt case_glob
    fi

    # Group matches and describe.
    zstyle ':completion:*:*:*:*:*' menu select
    zstyle ':completion:*:matches' group 'yes'
    zstyle ':completion:*:options' description 'yes'
    zstyle ':completion:*:options' auto-description '%d'
    zstyle ':completion:*:corrections' format ' %F{red}-- %d (errors: %e) --%f'
    zstyle ':completion:*:descriptions' format ' %F{purple}-- %d --%f'
    zstyle ':completion:*:messages' format ' %F{green} -- %d --%f'
    zstyle ':completion:*:warnings' format ' %F{yellow}-- no matches found --%f'
    zstyle ':completion:*' format ' %F{blue}-- %d --%f'
    zstyle ':completion:*' group-name ''
    zstyle ':completion:*' verbose yes

    # Fuzzy match mistyped completions.
    zstyle ':completion:*' completer _complete _match _approximate
    zstyle ':completion:*:match:*' original only
    zstyle ':completion:*:approximate:*' max-errors 1 numeric

    # Increase the number of errors based on the length of the typed word. But make
    # sure to cap (at 7) the max-errors to avoid hanging.
    zstyle -e ':completion:*:approximate:*' max-errors 'reply=($((($#PREFIX+$#SUFFIX)/3>7?7:($#PREFIX+$#SUFFIX)/3))numeric)'

    # Don't complete unavailable commands.
    zstyle ':completion:*:functions' ignored-patterns '(_*|pre(cmd|exec))'

    # Array completion element sorting.
    zstyle ':completion:*:*:-subscript-:*' tag-order indexes parameters

    # Directories
    zstyle ':completion:*:*:cd:*' tag-order local-directories directory-stack path-directories
    zstyle ':completion:*:*:cd:*:directory-stack' menu yes select
    zstyle ':completion:*:-tilde-:*' group-order 'named-directories' 'path-directories' 'users' 'expand'
    zstyle ':completion:*' squeeze-slashes true
    zstyle ':completion:*' special-dirs ..

    # History
    zstyle ':completion:*:history-words' stop yes
    zstyle ':completion:*:history-words' remove-all-dups yes
    zstyle ':completion:*:history-words' list false
    zstyle ':completion:*:history-words' menu yes

    # Environment Variables
    zstyle ':completion::*:(-command-|export):*' fake-parameters ${${${_comps[(I)-value-*]#*,}%%,*}:#-*-}

    # Populate hostname completion. But allow ignoring custom entries from static
    # */etc/hosts* which might be uninteresting.
    zstyle -a ':zephyr:plugin:compstyle:*:hosts' etc-host-ignores '_etc_host_ignores'

    zstyle -e ':completion:*:hosts' hosts 'reply=(
      ${=${=${=${${(f)"$(cat {/etc/ssh/ssh_,~/.ssh/}known_hosts(|2)(N) 2> /dev/null)"}%%[#| ]*}//\]:[0-9]*/ }//,/ }//\[/ }
      ${=${(f)"$(cat /etc/hosts(|)(N) <<(ypcat hosts 2> /dev/null))"}%%(\#${_etc_host_ignores:+|${(j:|:)~_etc_host_ignores}})*}
      ${=${${${${(@M)${(f)"$(cat ~/.ssh/config 2> /dev/null)"}:#Host *}#Host }:#*\**}:#*\?*}}
    )'

    # Don't complete uninteresting users...
    zstyle ':completion:*:*:*:users' ignored-patterns \
      adm amanda apache avahi beaglidx bin cacti canna clamav daemon \
      dbus distcache dovecot fax ftp games gdm gkrellmd gopher \
      hacluster haldaemon halt hsqldb ident junkbust ldap lp mail \
      mailman mailnull mldonkey mysql nagios \
      named netdump news nfsnobody nobody nscd ntp nut nx openvpn \
      operator pcap postfix postgres privoxy pulse pvm quagga radvd \
      rpc rpcuser rpm shutdown squid sshd sync uucp vcsa xfs '_*'

    # ... unless we really want to.
    zstyle '*' single-ignored show

    # Ignore multiple entries.
    zstyle ':completion:*:(rm|kill|diff):*' ignore-line other
    zstyle ':completion:*:rm:*' file-patterns '*:all-files'

    # Kill
    zstyle ':completion:*:*:*:*:processes' command 'ps -u $LOGNAME -o pid,user,command -w'
    zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#) ([0-9a-z-]#)*=01;36=0=01'
    zstyle ':completion:*:*:kill:*' menu yes select
    zstyle ':completion:*:*:kill:*' force-list always
    zstyle ':completion:*:*:kill:*' insert-ids single

    # Man
    zstyle ':completion:*:manuals' separate-sections true
    zstyle ':completion:*:manuals.(^1*)' insert-sections true
    zstyle ':completion:*:man:*' menu yes select

    # Media Players
    zstyle ':completion:*:*:mpg123:*' file-patterns '*.(mp3|MP3):mp3\ files *(-/):directories'
    zstyle ':completion:*:*:mpg321:*' file-patterns '*.(mp3|MP3):mp3\ files *(-/):directories'
    zstyle ':completion:*:*:ogg123:*' file-patterns '*.(ogg|OGG|flac):ogg\ files *(-/):directories'
    zstyle ':completion:*:*:mocp:*' file-patterns '*.(wav|WAV|mp3|MP3|ogg|OGG|flac):ogg\ files *(-/):directories'

    # Mutt
    if [[ -s "$HOME/.mutt/aliases" ]]; then
      zstyle ':completion:*:*:mutt:*' menu yes select
      zstyle ':completion:*:mutt:*' users ${${${(f)"$(<"$HOME/.mutt/aliases")"}#alias[[:space:]]}%%[[:space:]]*}
    fi

    # SSH/SCP/RSYNC
    zstyle ':completion:*:(ssh|scp|rsync):*' tag-order 'hosts:-host:host hosts:-domain:domain hosts:-ipaddr:ip\ address *'
    zstyle ':completion:*:(scp|rsync):*' group-order users files all-files hosts-domain hosts-host hosts-ipaddr
    zstyle ':completion:*:ssh:*' group-order users hosts-domain hosts-host users hosts-ipaddr
    zstyle ':completion:*:(ssh|scp|rsync):*:hosts-host' ignored-patterns '*(.|:)*' loopback ip6-loopback localhost ip6-localhost broadcasthost
    zstyle ':completion:*:(ssh|scp|rsync):*:hosts-domain' ignored-patterns '<->.<->.<->.<->' '^[-[:alnum:]]##(.[-[:alnum:]]##)##' '*@*'
    zstyle ':completion:*:(ssh|scp|rsync):*:hosts-ipaddr' ignored-patterns '^(<->.<->.<->.<->|(|::)([[:xdigit:].]##:(#c,2))##(|%*))' '127.0.0.<->' '255.255.255.255' '::1' 'fe80::*'
  }

  # Load with `autoload -Uz compstyleinit; compstyleinit'.
  # Type `compstyle -h' for help.
  function compstyleinit {
    typeset -gaU completion_styles
    typeset -ga completion_style
    completion_styles=(zephyr)

    function compstyleinit {
      emulate -L zsh; setopt extendedglob

      local name setupfn
      local -a match

      # Autoload all compstyle_*_setup functions in fpath.
      for setupfn in $^fpath/compstyle_*_setup(N); do
        if [[ $setupfn == */compstyle_(#b)(*)_setup ]]; then
          name="$match[1]"
          if [[ -r "$setupfn" ]]; then
            completion_styles=($completion_styles $name)
            autoload -Uz compstyle_${name}_setup
          else
            print "Cannot read '$setupfn' file containing completion styles."
          fi
        else
          print "Unexpect compstyle setup function '$setupfn'."
        fi
      done
    }

    function _compstyle_usage {
      emulate -L zsh; setopt extended_glob
      local -a usage=(
        'Usage: compstyle [-l] [-h [<style>]]'
        '       compstyle <style>'
        'Options:'
        '  -l            List currently available completion styles'
        '  -h [<style>]  Display help (for given compstyle)'
        'Arguments:'
        '  <style>       Switch to new compstyle'
        ''
        'Use `compstyle -h` for help.'
        'Load with `autoload -Uz compstyleinit; compstyleinit`.'
        'Set completion style with `compstyle <compstyle>`.'
      )

      if [[ -n "$1" && -n "$completion_styles[(r)$1]" ]]; then
        # Run this in a subshell, so we don't need to clean up afterwards.
        (
          # If we can't find a _help function, run the _setup function to see
          # if it will create one.
          (( $+functions[compstyle_$1_help] )) || compstyle_$1_setup

          # ...then try again.
          if (( $+functions[compstyle_$1_help] )); then
            print "Help for '$1' completion style:\n"
            compstyle_$1_help
          else
            print "No help available for '$1' completion style."
          fi
        )
      else
        printf '%s\n' "${usage[@]}"
      fi
    }

    function compstyle {
      # compstyle [-l] [-h [<style>]]
      local opt
      while getopts 'lh' opt; do
        case "$opt" in
          l) print Currently available completion styles:
            print $completion_styles
            return
            ;;
          h) _compstyle_usage "$@[2,-1]"; return $? ;;
          *) _compstyle_usage;            return 2  ;;
        esac
      done

      # error if compstyle specified not found
      if [[ -z "$1" || -z $completion_styles[(r)$1] ]]; then
        print >&2 "compstyle: Completion style not found '$1'."
        _compstyle_usage
        return 1
      fi

      # TODO: cleanup any prior completion styles

      # set the new completion styles
      compstyle_$1_setup "$@[2,-1]" && completion_style=( "$@" )
    }

    compstyleinit "$@"
  }
}

#
#endregion
#region completion
#
# Return if requirements are not found.
[[ "$TERM" != 'dumb' ]] || return 1

# Set completion options.
setopt always_to_end        # Move cursor to the end of a completed word.
setopt auto_list            # Automatically list choices on ambiguous completion.
setopt auto_menu            # Show completion menu on a successive tab press.
setopt auto_param_slash     # If completed parameter is a directory, add a trailing slash.
setopt complete_in_word     # Complete from both ends of a word.
setopt path_dirs            # Perform path search even on command names with slashes.
setopt NO_flow_control      # Disable start/stop characters in shell editor.
setopt NO_menu_complete     # Do not autoselect the first completion entry.

# Allow Fish-like user contributed completions.
fpath=($__zsh_config_dir/completions(-/FN) $fpath)

function run_compinit {
  emulate -L zsh
  setopt local_options extended_glob

  # Use ZSH_COMPDUMP for the completion file.
  typeset -g ZSH_COMPDUMP
  if [[ -z "$ZSH_COMPDUMP" ]]; then
    if zstyle -T ':zephyr:plugin:completion' use-xdg-basedirs; then
      ZSH_COMPDUMP=$__zsh_cache_dir/zcompdump
    else
      ZSH_COMPDUMP=$HOME/.zcompdump
    fi
  fi

  # Make sure ZSH_COMPDUMP's directory exists and doesnt' have a leading tilde.
  ZSH_COMPDUMP="${~ZSH_COMPDUMP}"
  [[ -d $ZSH_COMPDUMP:h ]] || mkdir -p $ZSH_COMPDUMP:h

  # `run_compinit -f` forces a cache reset.
  if [[ "$1" == (-f|--force) ]]; then
    shift
    [[ -r "$ZSH_COMPDUMP" ]] && rm -rf -- "$ZSH_COMPDUMP"
  fi

  # compinit flags: https://zsh.sourceforge.io/Doc/Release/Completion-System.html#Use-of-compinit
  # -C        : Omit the check for new completion functions
  # -i        : Ignore insecure directories from fpath
  # -u        : Allow insecure directories in fpath
  # -d <file> : Specify zcompdump file
  local -a compinit_flags=(-i)
  if zstyle -t ':zephyr:plugin:completion' 'disable-compfix'; then
    compinit_flags=(-u $compinit_flags)
  fi
  compinit_flags+=(-d "$ZSH_COMPDUMP")

  # Initialize completions
  autoload -Uz compinit
  if zstyle -t ':zephyr:plugin:completion' 'use-cache'; then
    # Load and initialize the completion system ignoring insecure directories with a
    # cache time of 20 hours, so it should almost always regenerate the first time a
    # shell is opened each day.
    local zcompdump_cache=($ZSH_COMPDUMP(Nmh-20))
    if (( $#zcompdump_cache )); then
      compinit -C $compinit_flags
    else
      compinit $compinit_flags
      touch "$ZSH_COMPDUMP"  # Ensure timestamp updates to reset the cache timeout.
    fi
  else
    compinit $compinit_flags
  fi

  # Compile ZSH_COMPDUMP, if modified, in background to increase startup speed.
  {
    if [[ -s "$ZSH_COMPDUMP" && (! -s "${ZSH_COMPDUMP}.zwc" || "$ZSH_COMPDUMP" -nt "${ZSH_COMPDUMP}.zwc") ]]; then
      if command mkdir "${ZSH_COMPDUMP}.zwc.lock" 2>/dev/null; then
        zcompile "$ZSH_COMPDUMP"
        command rmdir  "${ZSH_COMPDUMP}.zwc.lock" 2>/dev/null
      fi
    fi
  } &!
}

# Let's talk about compinit for a second...
# compinit works by finding _completion files in your fpath. That means fpath needs to
# be fully populated prior to calling it. But sometimes you need to call compdef before
# fpath is done being populated (eg: plugins do this). compinit has big chicken-and-egg
# problems. This code handles all those completion use-cases by wrapping compinit,
# queueing any calls to compdef, and hooking the real call to compinit to Zephyr's
# custom post_zshrc event.

# Define compinit placeholder functions (compdef) so we can queue up calls.
# That way when the real compinit is called, we can execute the queue.
typeset -gHa __compdef_queue=()
function compdef {
  (( $# )) || return
  local compdef_args=("${@[@]}")
  __compdef_queue+=("$(typeset -p compdef_args)")
}

# Wrap compinit temporarily so that when the real compinit call happens, the
# queue of compdef calls is processed.
function compinit {
  unfunction compinit compdef &>/dev/null
  autoload -Uz compinit && compinit "$@"

  # Apply all the queued compdefs.
  local typedef_compdef_args
  for typedef_compdef_args in $__compdef_queue; do
    eval $typedef_compdef_args
    compdef "$compdef_args[@]"
  done
  unset __compdef_queue

  # We can run compinit early, and if we did we no longer need a post_zshrc hook.
  post_zshrc_hook=(${post_zshrc_hook:#run_compinit})
}

# Set the completion style
zstyle -s ':zephyr:plugin:completion' compstyle 'zcompstyle' || zcompstyle=zephyr
if (( $+functions[compstyle_${zcompstyle}_setup] )); then
  compstyle_${zcompstyle}_setup
elif [[ "$zcompstyle" != none ]]; then
  compstyleinit
  compstyle ${zcompstyle}
fi
unset zcompstyle

# Allow the user to bypass the compinit deferral and run it immediately. Otherwise, we
# hook run_compinit to the custom post_zshrc event.
if zstyle -t ':zephyr:plugin:completion' immediate; then
  run_compinit || return 1
else
  post_zshrc_hook+=(run_compinit)
fi
#
#endregion
#region confd
#
function run_confd {
  # Find the conf.d directory.
  local confd user_confd
  zstyle -a ':zephyr:plugin:confd' directory 'user_confd'
  local -a confd_choices=(
    ${~user_confd}
    $__zsh_config_dir/conf.d(N)
    $__zsh_config_dir/zshrc.d(N)
    $__zsh_config_dir/rc.d(N)
    ${ZDOTDIR:-$HOME}/.zshrc.d(N)
  )
  confd=$confd_choices[1]
  #echo "THE CONFD DIR IS: $confd"
  if [[ ! -e "$confd" ]]; then
    echo >&2 "confd: dir not found '${confd:-$__zsh_config_dir/conf.d}'."
    return 1
  fi

  # Sort and source all scripts in conf.d.
  local rc; local -a rcs=(${confd}/*.{z,}sh(N))
  for rc in ${(o)rcs}; do
    # ignore files that begin with ~
    [[ "${rc:t}" != '~'* ]] || continue
    source "$rc"
  done

  # We can run this early, so if we did we no longer need a post_zshrc hook.
  post_zshrc_hook=(${post_zshrc_hook:#run_confd})
}

# Allow the user to bypass the confd deferral and run it immediately. Otherwise, we
# hook run_confd to the custom post_zshrc event.
if zstyle -t ':zephyr:plugin:confd' immediate; then
  run_confd || return 1
else
  post_zshrc_hook+=(run_confd)
fi
#
#endregion

# vim: ft=zsh sw=2 ts=2 et
